(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{443:function(n,t,s){"use strict";s.r(t);var a=s(56),e=Object(a.a)({},(function(){var n=this,t=n.$createElement,s=n._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("h1",{attrs:{id:"知识点"}},[n._v("知识点")]),n._v(" "),s("h2",{attrs:{id:"一、计算机基础"}},[n._v("一、计算机基础")]),n._v(" "),s("p",[s("strong",[n._v("机器数: 原码 补码 反码")])]),n._v(" "),s("blockquote",[s("p",[n._v("练习： [x]补=1 1110100， [y]补=10110000。若整型变量 z=2*x+y/2，则 z 的机器数为（ ）。")])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("第一步：根据补码算反码（正数的补码与其原码相同；负数的补码是在其反码的末位加1）\n\n反码: x: 11110011   y: 10101111\n\n第二步：根据反码算原码（正数的反码与其原码相同；负数的反码是对其原码逐位取反，符号位除外）\n\n原码: x: 10001100   y: 11010000\n\n第三步：分别计算2*x和y/2\n\n10001100 向左移一位\n2*x =  10011000\n\n11010000  向右移一位\ny/2 = 10101000\n\n第四步：计算2*x+y/2\n\n10011000\n+  10101000\n\nz=2*x+y/2 = 11000000\n\n\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br")])]),s("h2",{attrs:{id:"二、java基础"}},[n._v("二、Java基础")]),n._v(" "),s("p",[s("strong",[n._v("1.String 与 Integer :")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v("【String】\n1.String常量池：字符串常量放在常量池中实现复用，指向常量池中同一个内存地址；\n\n2.为什么String是不可变的：成员变量final，并且没有set方法来修改\n")])])]),s("p",[n._v("​"),s("br"),n._v("\n​    【Integer】\n​    java中一个字节以内的Integer，-128~127都是存在一个常量池中的，所以他们的引用也是相同的\n​"),s("br"),n._v("\n​    \tInteger i1 = 127;\n​    \tInteger i2 = 127;\n​"),s("br"),n._v("\n​    \tSystem.out.println(i1 == i2);\n​"),s("br"),n._v("\n​    \t结果是true；\n​    \t\n​        ---------------------------------\n​"),s("br"),n._v("\n自动装箱的时候会调用Integer.valueof方法，会与IntegerCache里面的最大最小值做比较，在这个范围里的值就会直接取IntegerCache里的\nInteger i1 = 128;\nInteger i2 = 128;")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v("\tSystem.out.println(i1 == i2);\n\n\t结果是false；\n\t\n\t---------------------------------\n\tInteger i1 = 2000000000;\n\tInteger i2 = 2000000000;\n\n\tSystem.out.println(i1 == i2);\n\t\n\t结果是false；\n")])])]),s("p",[s("strong",[n._v("2.new")]),n._v("：")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v("创建新的对象，指向全新的内存地址；\n\nString类的intern方法创建返回一个常量池中的固定对象\n")])])]),s("p",[s("strong",[n._v("3.static")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v("1、创建独立于对象的域变量或者方法\n\n2、修饰成员、成员方法、代码块、静态内部类\n\n3、类加载时就会加载被static修饰的部分，JVM会为静态变量分配内存空间\n\n4、静态方法可以访问静态的变量，不能访问非静态的；非静态的可以访问静态的\n")])])]),s("p",[s("strong",[n._v("4.final")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v("1.修饰类，这个类不能被继承\n\n2、修饰方法，这个方法不能被重写\n\t一个类的private方法会隐式的指定为final方法\n\t如果父类有final方法，子类不能去重写\n\t\n3.修饰成员变量，必须要赋初始值，而且只能初始化一次\n\t被final修饰的成员变量赋值两种方式：（1）直接赋值（2）在构造方法中赋初始值\n\t如果修饰的成员变量是基本类型，那么这个变量的值不能改变\n\t如果修饰的是引用类型，那么表示引用地址不能改变，引用指向的对象的内容还是可以改变的\n")])])]),s("p",[s("strong",[n._v("5.transient")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v("关于对象序列化，类实现serializable接口\n\t对象转成字节序列，序列化后的对象可以写入到数据库或文件中，网络传输\n\t反序列化，序列化后的字节序列恢复原先的Java对象\n\t\ntransient：让对象中的某些成员变量属性不被序列化\n\t不需要被保存，节省存储空间\n")])])]),s("p",[s("strong",[n._v("6.反射")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v('定义：\n\t在运行状态中，对于任意的一个类，能够知道这个了类的所有属性和方法；对于任何一个对象，都能调用它的任意方法和属性；这种动态获取类信息及动态调用对象的方法功能称之为Java的反射机制。\n\n原理：\n\tClass.forName("c.a.xxx");//java.lang.Class的静态方法，获取类信息\n\t{\n\t\t//通过反射，获取调用进来的类信息，从而获取当前的classLoader\n\t\tClass<?> caller = Reflection.getCallerClass();\n\t\t//调用native方法，获取class信息\n\t\tforName0(className, true, ClassLoader.getClassLoader(caller), caller)\n\t\t\n\t}\n')])])]),s("p",[s("strong",[n._v("7.抽象类与接口")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v("定义本身：\n\t接口是完全抽象的；抽象类是半抽象的；（体现在接口中的方法只有名，没有具体实现；java8有了default方法；抽象类可以有具体方法）\n\t\n\t抽象类的成员变量可以是各种类型，而接口中的成员变量只能是public static final\n\t\n使用：\n\t一个类只能继承一个抽象类，但可以实现多个接口\n\t抽象类像一个模板，接入像一个行为规范\n")])])]),s("h2",{attrs:{id:"三、java集合"}},[n._v("三、java集合")]),n._v(" "),s("blockquote",[s("p",[n._v("ArrayList、 LinkedList")])]),n._v(" "),s("blockquote",[s("p",[n._v("HashMap、TreeMap")])]),n._v(" "),s("table",[s("thead",[s("tr",[s("th",[n._v("HashMap")]),n._v(" "),s("th",[n._v("TreeMap")])])]),n._v(" "),s("tbody",[s("tr",[s("td",[n._v("1.基于数组 + 链表 - > 红黑树")]),n._v(" "),s("td",[n._v("1.基于红黑树，有序")])]),n._v(" "),s("tr",[s("td",[n._v("2.查询较快，最差O(log n)")]),n._v(" "),s("td",[n._v("2.时间复杂度O(log n)")])]),n._v(" "),s("tr",[s("td",[n._v("3.插入：hashcode(key)、key.equal()确定位置")]),n._v(" "),s("td",[n._v("3.增加节点，从根节点出发作为当前节点比较，循环")])]),n._v(" "),s("tr",[s("td",[n._v("4.删除节点，比较复杂")]),n._v(" "),s("td",[n._v("4.删除节点:找到被删除的节点D的子节点C，用C来替代D，不是直接删除D，因为D被C替代了，直接删除C即可"),s("br"),n._v("子节点C的规则是：右分支最左边，或者 左分支最右边的")])])])]),n._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[n._v("put")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("k"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v(" v"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[n._v("->")]),n._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[n._v("putVal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[n._v("hash")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v(" k"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v(" v"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[n._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[n._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[n._v("//1、判断初始容量，Node<K,V>[] tab若为null，则进行初始化，初始化容量为16。")]),n._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[n._v("//2、判断tab数组索引位置的值是否为null，是则构造新节点并赋值：tab[i] = newNode(hash, key, value, null);")]),n._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[n._v("//3、（1）判断tab数组索引位置key值以及hash值与将要插入的元素的key值和hash值是否相等，若相等，覆盖原有的值")]),n._v("\n    （"),s("span",{pre:!0,attrs:{class:"token number"}},[n._v("2")]),n._v("）如果索引所在的位置是"),s("span",{pre:!0,attrs:{class:"token class-name"}},[n._v("TreeNode")]),n._v("，将元素插入到"),s("span",{pre:!0,attrs:{class:"token class-name"}},[n._v("TreeNode")]),n._v("中："),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[n._v("TreeNode")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[n._v("K")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[n._v("V")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(">")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("p"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[n._v("putTreeVal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v(" tab"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v(" hash"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v(" key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v("\n    （"),s("span",{pre:!0,attrs:{class:"token number"}},[n._v("3")]),n._v("）如果索引所在的位置是链表，将元素插入到链表尾部，当链表元素数量到达"),s("span",{pre:!0,attrs:{class:"token number"}},[n._v("8")]),n._v("时，转"),s("span",{pre:!0,attrs:{class:"token class-name"}},[n._v("TreeNode")]),n._v("\n   \t\t\t\t\t\t  \n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[n._v("//4、插入完成后，判断当前容量是否超出初始的负载容量，来确定是否需要扩容")]),n._v("\n\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),n._v("\n\n"),s("span",{pre:!0,attrs:{class:"token function"}},[n._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[n._v("->")]),n._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[n._v("getNode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[n._v("hash")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v(" key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[n._v("//1、判断是否容量大于0 ，否则返回 null")]),n._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[n._v("//2、（1）判断当前索引的hash值以及key值是否等于要找的元素")]),n._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[n._v("//\t （2）如果当前索引是红黑树，则去树中去遍历查找，直至找到")]),n._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[n._v("//   （3）如果当前索引是链表，则向后查找，根据hash值和key值去匹配，直至找到")]),n._v("\n\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),n._v("\n\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br")])]),s("blockquote",[s("p",[n._v("ConcurrentHashMap")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v("concurrentHashMap内部原理，如何保证线程安全\t\n")])])]),s("p",[n._v("​\t锁分段技术\n​\t读是否加锁，why\n​\t迭代器是强一致性还是弱一致性的迭代器")]),n._v(" "),s("blockquote",[s("p",[n._v("HashSet")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v("set如何保证不重复\n")])])]),s("h2",{attrs:{id:"四、io"}},[n._v("四、IO")]),n._v(" "),s("ul",[s("li",[n._v("HTTP/tcp/udp网络协议原理")])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("HTTP协议是构建在tcp/ip协议之上的，是tcp/ip协议的一个子集；\n\ntcp/ip协议族四层协议：\n    应用层：HTTP、FTP、DNS等\n    传输层：TCP、UDP\n    网络层：处理网络上流动的数据包\n    数据链路层：处理连接网络的硬件部分\n   \nTCP三次握手：\n\t1）客户端发送SYN标志的连接请求报文段，然后进入SYN_SEND状态，等待服务端的确认\n\t2）服务端接收到客户端的SYN报文段后，需要发送ACK信息对这个SYN报文段进行确认；同时，是要发送自己的SYN请求信息，服务端会将上述信息放到一个报文段（SYN+ACK报文段）中，一并发送给客户端，此时，服务端进入SYN_RECV状态\n\t3）客户端收到服务端的SYN+ACK报文段后，会向服务端发送ACK确认报文段，这个报文段发送完毕，客户端和服务端都进入ESTABLISHED状态，完成TCP三次握手\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br")])]),s("ul",[s("li",[s("p",[n._v("BIO")]),n._v(" "),s("p",[n._v("同步阻塞IO")])]),n._v(" "),s("li",[s("p",[n._v("NIO")])])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("同步非阻塞IO\n\t\n核心类：\n\t1.Channel(通道) \n\t\t特性：\n\t\t\t双向性\n\t\t\t非阻塞性\n\t\t\t操作唯一性 （通过buffer操作）\n\t\t实现：\n\t2.Buffer\n\t\t作用：读写Channel中的数据\n\t\t本质：一块内存区域\n\t\t属性：\n\t\t\tCapacity（容量）\n\t\t\tPosition（位置）\n\t\t\tlimit（上限）\n\t\t\tMark（标记）\n\t3.Selector\n\t\t\n步骤：\n\t1）创建Selector\n\t2）通过ServerSocketChannel创建Channel通道\n\t3）为channel通道绑定监听端口\n\t4）设置channel为非阻塞模式\n\t5）将channel注册到selector上，监听连接事件\n\t6）循环等待新的连接\n\t7）根据就绪状态，调用对应的方法处理业务逻辑\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br")])]),s("ul",[s("li",[s("p",[n._v("netty")]),n._v(" "),s("p",[n._v("netty封装了JDK的NIO，是一个异步事件驱动的网络应用框架，用于快速开发可维护的高性能服务器和客户端")])])]),n._v(" "),s("h2",{attrs:{id:"五、java并发"}},[n._v("五、java并发")]),n._v(" "),s("h3",{attrs:{id:"thread"}},[n._v("Thread")]),n._v(" "),s("p",[n._v("sleep()与wait()")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v("Thread.sleep() 释放CPU资源，不释放锁\n\nObject.wait() 释放锁，需要notify唤醒线程，重新获取锁；\n")])])]),s("p",[n._v("yield()")]),n._v(" "),s("blockquote",[s("p",[n._v("当前线程让出CPU时间片")])]),n._v(" "),s("p",[n._v("notify()与notifyall()")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v("notify唤醒一个线程，并允许它去获取锁\n\nnotifyall唤醒所有等待这个对象的线程，允许他们去获取对象锁；\n")])])]),s("p",[n._v("join()")]),n._v(" "),s("blockquote",[s("p",[n._v("等待子线程终止；")]),n._v(" "),s("p",[n._v("join方法的原理就是调用wait方法进行等待操作，子线程执行完JVM会自动调用notify方法唤醒主线程，主线程继续执行；")])]),n._v(" "),s("h3",{attrs:{id:"threadlocal"}},[n._v("ThreadLocal")]),n._v(" "),s("blockquote",[s("p",[n._v("ThreadLocal为每一个线程提供独立的变量副本，隔离了多个线程对数据的访问冲突；")])]),n._v(" "),s("h3",{attrs:{id:"同步辅助类"}},[n._v("同步辅助类")]),n._v(" "),s("h4",{attrs:{id:"_1-countdownlatch"}},[n._v("1.CountDownLatch")]),n._v(" "),s("blockquote",[s("p",[n._v("同步计数器，实现一个或多个线程等待，直到其他线程的操作完成")])]),n._v(" "),s("p",[n._v("使用场景：父线程需要等待子线程的执行结果，才能执行后续操作")]),n._v(" "),s("p",[n._v("CountDownLatch countDownLatch = new CountDownLatch(threadCount);")]),n._v(" "),s("p",[n._v("子线程执行完成，countDown()，父线程await()等待。")]),n._v(" "),s("h4",{attrs:{id:"_2-cyclicbarrier"}},[n._v("2.CyclicBarrier")]),n._v(" "),s("blockquote",[s("p",[n._v("一组线程相互等待，直到达到一个公共的屏障点，各个线程唤醒继续执行后续操作")])]),n._v(" "),s("p",[n._v("private static CyclicBarrier cyclicBarrier = new CyclicBarrier(5);")]),n._v(" "),s("p",[n._v("await()")]),n._v(" "),s("h4",{attrs:{id:"_3-semaphore"}},[n._v("3.SemaPhore")]),n._v(" "),s("blockquote",[s("p",[n._v("控制同一时间并发线程的数量")])]),n._v(" "),s("p",[n._v("使用场景：对于连接资源有限的情况下，控制并发限制")]),n._v(" "),s("p",[n._v("final Semaphore semaphore = new Semaphore(3);")]),n._v(" "),s("p",[n._v("acquire()")]),n._v(" "),s("p",[n._v("release()")]),n._v(" "),s("h3",{attrs:{id:"锁"}},[n._v("锁")]),n._v(" "),s("h4",{attrs:{id:"synchronized关键字"}},[n._v("Synchronized关键字")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v(" Synchronized：\n\n\t同步方法：线程A调用加锁的A方法，或得到对象锁，等A方法执行完，其他线程才能调用A方法\n\t同步代码块：缩小同步范围，提高执行效率，可指定锁对象\t\n\t加到static方法给class类上锁，加到非静态方法是给对象上锁\n\t锁重入：线程得到对象锁后，再次请求此对象锁，可再次得到；在Synchronized方法内部再次调用其他\n\t非公平\n")])])]),s("h4",{attrs:{id:"reentrantlock"}},[n._v("ReenTrantLock")]),n._v(" "),s("h4",{attrs:{id:"reentrantreadwritelock"}},[n._v("ReenTrantReadWriteLock")]),n._v(" "),s("h4",{attrs:{id:"stampedlock"}},[n._v("StampedLock")]),n._v(" "),s("h4",{attrs:{id:"condition"}},[n._v("Condition")])])}),[],!1,null,null,null);t.default=e.exports}}]);