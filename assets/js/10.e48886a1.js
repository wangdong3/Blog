(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{402:function(v,_,e){v.exports=e.p+"assets/img/kafka1.65f4770c.png"},438:function(v,_,e){"use strict";e.r(_);var a=e(56),t=Object(a.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"kafka"}},[a("code",[v._v("kafka")])]),v._v(" "),a("h2",{attrs:{id:"前言-kafka设计"}},[v._v("前言："),a("code",[v._v("kafka")]),v._v("设计")]),v._v(" "),a("ul",[a("li",[a("p",[a("strong",[v._v("磁盘顺序读写")])]),v._v(" "),a("p",[a("code",[v._v("kafka")]),v._v("的消息是顺序写到磁盘文件的末尾，以此能提升写入性能。"),a("code",[v._v("topic")]),v._v("的每个分区都是一个文件，收到消息，"),a("code",[v._v("kafka")]),v._v("会把消息插入到文件的末尾。\n每个消费者对其订阅的"),a("code",[v._v("topic")]),v._v("都有一个"),a("code",[v._v("offset")]),v._v("来表示读取到了第几条数据。")])]),v._v(" "),a("li",[a("p",[a("strong",[v._v("页缓存")])]),v._v(" "),a("p",[v._v("利用操作系统本身的"),a("code",[v._v("page cache")]),v._v("来优化读写性能，"),a("code",[v._v("kafka")]),v._v("的读写基于内存，速度快")])]),v._v(" "),a("li",[a("p",[a("strong",[v._v("零拷贝")])]),v._v(" "),a("p",[v._v("减少应用程序与操作系统上下文切换")])]),v._v(" "),a("li",[a("p",[a("strong",[v._v("分区分段 + 索引")])]),v._v(" "),a("p",[a("code",[v._v("kafka")]),v._v(" 的消息按"),a("code",[v._v("topic")]),v._v("分类存放，一个"),a("code",[v._v("topic")]),v._v("的消息又是可以存放到多个"),a("code",[v._v("partition")]),v._v("，每个分区对应一个"),a("code",[v._v("broker")]),v._v("节点，这个符合分布式系统的设计思想。\n每个分区又会分段，消息实际上存放在各个分区的"),a("code",[v._v("segment")]),v._v("上，每次文件操作就是操作这个"),a("code",[v._v("segment")]),v._v("，为了进一步的优化，"),a("code",[v._v("kafka")]),v._v("为每个分段文件建立一个索引文件。")])])]),v._v(" "),a("blockquote",[a("p",[v._v("这种设计提高了读取速率，同时也提高数据操作的并行度。")])]),v._v(" "),a("ul",[a("li",[a("p",[a("strong",[v._v("批量读写")])]),v._v(" "),a("p",[v._v("写入消息时，启用批次写入，这样可以避免在网络中频繁网络请求，提高吞吐量；")]),v._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[v._v("//默认16kb，不宜过大，过大会有延迟\nbatch.size=16384\n")])]),v._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[v._v("1")]),a("br"),a("span",{staticClass:"line-number"},[v._v("2")]),a("br")])])]),v._v(" "),a("li",[a("p",[a("strong",[v._v("批量压缩")])]),v._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[v._v("//设置发送消息的缓冲区大小，默认32M\nbuffer.memory=33554432\n//开启gzip压缩，减少网络`io`损耗\ncompression-type: gzip\n")])]),v._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[v._v("1")]),a("br"),a("span",{staticClass:"line-number"},[v._v("2")]),a("br"),a("span",{staticClass:"line-number"},[v._v("3")]),a("br"),a("span",{staticClass:"line-number"},[v._v("4")]),a("br")])]),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[v._v("  批量读写和批量压缩都是`kafka`提高吞吐量的设计优点。\n")])])])])]),v._v(" "),a("h2",{attrs:{id:"kafka相关概念"}},[a("code",[v._v("kafka")]),v._v("相关概念")]),v._v(" "),a("p",[a("img",{attrs:{src:e(402),alt:""}})]),v._v(" "),a("ul",[a("li",[a("p",[a("strong",[v._v("broker")]),v._v("：存储消息")])]),v._v(" "),a("li",[a("p",[a("strong",[v._v("producer")]),v._v("：生产者，发送消息")])]),v._v(" "),a("li",[a("p",[a("strong",[v._v("consumer")]),v._v("：消费消息，完成消息的读取及后续的业务处理")])]),v._v(" "),a("li",[a("p",[a("strong",[v._v("consumer group")]),v._v("：消费者组，管理一组消费者，同组消费者可以消费订阅的同一个主题的消息。")])]),v._v(" "),a("li",[a("p",[a("strong",[v._v("group coordinator")]),v._v("：每个消费者组会选择一个"),a("code",[v._v("broker")]),v._v("来监控消费者组里面各个消费者的心跳情况，以及判断是否宕机，这个"),a("code",[v._v("broker")]),v._v("就是"),a("code",[v._v("coordinator")])]),v._v(" "),a("p",[a("code",[v._v("hash(groupId)/partition")]),v._v("，找到分区所在的"),a("code",[v._v("broker")]),v._v("，作为"),a("code",[v._v("coordinator")])]),v._v(" "),a("p",[a("strong",[a("code",[v._v("rebalance")])]),v._v("：策略：")]),v._v(" "),a("p",[v._v("​\t（1）range策略，按照分区范围进行消费")]),v._v(" "),a("p",[v._v("​\t（2）round-robin，轮询")]),v._v(" "),a("p",[v._v("​\t（3）sticky策略，尽量不懂属于原本消费者消费的分区，把空闲多余的分区在分配给各个存活的消费者")])]),v._v(" "),a("li",[a("p",[a("strong",[v._v("topic")]),v._v("（逻辑上的概念）消息按"),a("code",[v._v("topic")]),v._v("进行分类")])]),v._v(" "),a("li",[a("p",[a("strong",[v._v("partition")]),v._v("（分区，这个是真实的物理概念，每个分区都在不同的服务器上），对"),a("code",[v._v("topic")]),v._v("设置多个"),a("code",[v._v("partition")]),v._v("，所有的消息都会不断地追加到"),a("code",[v._v("partition")]),v._v("日志文件的末端，且每套消息都有自己的"),a("code",[v._v("offset")])])]),v._v(" "),a("li",[a("p",[a("strong",[v._v("文件存储")]),v._v("：")]),v._v(" "),a("ul",[a("li",[a("code",[v._v(".log")]),v._v("文件（存储消息）")]),v._v(" "),a("li",[a("code",[v._v(".index")]),v._v("文件，用来定位消息")])])]),v._v(" "),a("li",[a("p",[a("code",[v._v("offset")]),v._v(" 消息相对偏移量")])]),v._v(" "),a("li",[a("p",[a("strong",[a("code",[v._v("ack")])]),v._v("："),a("code",[v._v("[all, -1, 0, 1]")])]),v._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[v._v("//0:请求发出去，不保证消息发送成功；1：leader partition写成功；-1：ISR列表里面，所有副本写入完成，这条消息才算发送成功\nkafka.producer.acks=1\n")])]),v._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[v._v("1")]),a("br"),a("span",{staticClass:"line-number"},[v._v("2")]),a("br")])]),a("ul",[a("li",[a("strong",[a("code",[v._v("ISR")])]),v._v(" 保持同步的副本")])]),v._v(" "),a("p",[v._v("一个"),a("code",[v._v("leader partition")]),v._v("会维护一个"),a("code",[v._v("ISR")]),v._v("列表")]),v._v(" "),a("p",[v._v("为了保证生产者发送消息成功，"),a("code",[v._v("topic")]),v._v("的每个分区在收到消息后，都要向"),a("code",[v._v("producer")]),v._v("发送"),a("code",[v._v("ack")]),v._v("消息确认，生产者收到"),a("code",[v._v("ack")]),v._v("就会发送下一个消息，否则重新发送")]),v._v(" "),a("blockquote",[a("p",[a("code",[v._v("acks=all")]),v._v("集群副本同步主节点的消息成功，则发送"),a("code",[v._v("ack")]),v._v("，这样即使主节点挂掉，从节点也能及时选出新的主节点。")])])])]),v._v(" "),a("h2",{attrs:{id:"kafka与其他消息中间件相比-优劣势"}},[a("code",[v._v("kafka")]),v._v("与其他消息中间件相比，优劣势")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("吞吐量高。"),a("code",[v._v("tps")]),v._v("达到百万")])]),v._v(" "),a("li",[a("p",[v._v("单机支持的队列数不能过多")])]),v._v(" "),a("li",[a("p",[v._v("不支持消息查询")])]),v._v(" "),a("li",[a("p",[v._v("消息回溯")])]),v._v(" "),a("li",[a("p",[v._v("不支持"),a("code",[v._v("broker")]),v._v("端类似"),a("code",[v._v("tag")]),v._v("的消息过滤")])])]),v._v(" "),a("h2",{attrs:{id:"kafka操作指令"}},[a("code",[v._v("kafka")]),v._v("操作指令")]),v._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[v._v('./kafka-topics.sh --describe --zookeeper ip:port --topic "topicname"\n.kafka-topics.sh --zookeeper localhost:2181 --create --topic my-topic --partitions 1 --replication-factor 1 \n')])]),v._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[v._v("1")]),a("br"),a("span",{staticClass:"line-number"},[v._v("2")]),a("br")])]),a("h2",{attrs:{id:"问题思索"}},[v._v("问题思索")]),v._v(" "),a("ol",[a("li",[a("p",[a("code",[v._v("kafka")]),v._v("消息积压如何处理？")]),v._v(" "),a("p",[v._v("分析原因：")]),v._v(" "),a("p",[v._v("（1）消费者服务中间出现宕机，在这段时间生产者源源不断在生产消息就会积压；")]),v._v(" "),a("p",[v._v("（2）消费者服务消费能力不足，需要增多消费者服务；")]),v._v(" "),a("p",[v._v("（3）消费线程触发死锁或者资源等待；")]),v._v(" "),a("p",[v._v("（4）消费者每次拉取消息的量太小，导致单位时间内生产的消息比消费的的消息量小，导致消息积压，需要加大拉取消息的量；")]),v._v(" "),a("p",[v._v("处理：短时间内需要扩容消费者实例数来处理积压消息")])]),v._v(" "),a("li",[a("p",[v._v("如何保证顺序消费消息？")]),v._v(" "),a("p",[v._v("（1）一个主题只创建一个分区；")]),v._v(" "),a("p",[v._v("（2）生产者指定分区发消息；")])])])])}),[],!1,null,null,null);_.default=t.exports}}]);