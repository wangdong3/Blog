(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{445:function(t,v,_){"use strict";_.r(v);var e=_(56),n=Object(e.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("p",[t._v("1.概念：\n集群：集群中的多台服务器做相同的事情\n分布式：多个服务器做不同的事情")]),t._v(" "),_("p",[t._v("问题--》方案")]),t._v(" "),_("hr"),t._v(" "),_("p",[t._v("系统崩溃，服务器宕机，--》如何高可用呢，搞多台服务器，一台服务器出现问题，直接换到另一台继续提供服务")]),t._v(" "),_("p",[t._v("随着业务壮大，系统的响应时间变慢，吞吐量成了瓶颈--》搭建集群，负载均衡，分散系统压力")]),t._v(" "),_("p",[t._v("分布式的产生：\n面对复杂的业务，业务拆分，各个服务分散在不同的服务器，但同时对外还是一个整体的服务，简而言之 就是一组在不同服务器上相互协作的系统。")]),t._v(" "),_("p",[t._v("分布式后，还要保证性能、可用、弹性--》一系列的技术栈产生")]),t._v(" "),_("h2",{attrs:{id:"分布式通信"}},[t._v("分布式通信")]),t._v(" "),_("p",[t._v("​\tRPC和MQ\n​\t\tRPC不能流量削峰，MQ可以\n​\t\tRPC不能广播，MQ可以\n​\t\tRPC模块之间不能解耦")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[t._v("\tMQ不能保证延迟时间\n\tMQ不适合搞强一致性事务\n\t增加系统复杂度\n")])])]),_("p",[t._v("分布式资源管理和负载调度\n集中式结构\n非集中式结构")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[t._v("单体调度\n两层调度\n共享状态调度\n")])])]),_("h2",{attrs:{id:"分布式存储"}},[t._v("分布式存储")]),t._v(" "),_("p",[t._v("​\t主备、sharding分片\n​\tcap理论\n分布式计算\n​\tMapReduce\n​\tstream\n分布式可靠性\n​\t负载均衡\n​\t流量控制\n​\t故障隔离")]),t._v(" "),_("h2",{attrs:{id:"分布式锁"}},[t._v("分布式锁：")]),t._v(" "),_("blockquote",[_("p",[t._v("高并发下同一时间只能有一个线程可执行方法")])]),t._v(" "),_("h3",{attrs:{id:"基于数据库"}},[t._v("基于数据库：")]),t._v(" "),_("p",[t._v("​\t"),_("strong",[t._v("悲观锁")]),t._v("："),_("code",[t._v("select ... for update")]),t._v(" ，使用for update锁定行，如果执行成功立即返回，否则一直阻塞；")]),t._v(" "),_("p",[t._v("​\t\t优点：保证数据强一致性")]),t._v(" "),_("p",[t._v("​\t\t缺点：锁长时间不释放，会一直占用数据库连接，可能会将数据库连接池撑爆，影响其他服务；优先获得锁的线程如果因为某些原因，一直没有释放掉锁，可能会导致死锁；高并发大量请求排队，会影响数据库稳定性，消耗服务CPU。")]),t._v(" "),_("p",[t._v("​\t"),_("strong",[t._v("乐观锁")]),t._v("：表中添加时间戳或版本号字段 "),_("code",[t._v("update xx set version = new_version where xx=yy and version = old_version")])]),t._v(" "),_("p",[t._v("​\t\t优点：实现简单，复杂度低，保证数据一致性")]),t._v(" "),_("p",[t._v("​\t\t缺点：性能低，有锁表风险；长时间不提交事务，会占用连接资源；可靠性差；")]),t._v(" "),_("h3",{attrs:{id:"基于redis"}},[t._v("基于Redis")]),t._v(" "),_("p",[t._v("​\t实现思想：使用setnx命令加锁，并使用expire给锁加一个超时时间，超过该时间，则自动释放锁；锁的value值为随机生成的id，释放锁时要判断下，是不是该锁。")]),t._v(" "),_("p",[t._v("​\t优点：可靠性较好高；性能好；cap模型属于AP")]),t._v(" "),_("p",[t._v("​\t缺点：复杂度较高；可靠性不如zookeeper；锁删除失败，过期时间不好控制；非阻塞，获取锁失败，需要不断轮询获取锁，消耗CPU资源")]),t._v(" "),_("p",[t._v("基于zookeeper")]),t._v(" "),_("p",[t._v("​\t实现思想：zookeeper是一个为分布式应用提供一致性服务的开源组件，其内部是一个分层文件系统目录结构，线程加锁的时候，会在指定目录新建一个临时顺序节点，获取目录下所有子节点，寻找比自己小的兄弟节点，如果没有，那么当前线程的顺序节点最小，则获取锁成功。线程释放锁时会删除自己的节点，其他线程监听到变更事件，判断自己是不是最小节点，获取锁")]),t._v(" "),_("p",[t._v("​\t优点：可靠性高，cap模型属于CP")]),t._v(" "),_("p",[t._v("​\t缺点：实现复杂度高，性能不如Redis")])])}),[],!1,null,null,null);v.default=n.exports}}]);