# 设计模式

## 设计原则  

- **单一职责**：高内聚，低耦合。每个类专注于做意见事情
- **开闭原则**：对扩展开放，对修改关闭。对类的改动是通过增加代码进行，而不是修改现有的代码
- **里氏替换原则**：在任何父类出现的地方都可以用他的子类来替代
- **依赖倒置原则**：依赖于抽象，不依赖具体实现
- **接口隔离原则**：使用多个隔离的接口，而不是使用单个接口，降低依赖耦合
- **合成复用原则**：合成复用原则就是指在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用其已有功能的目的。简言之：要尽量使用组合/聚合关系，少用继承。
- **迪米特原则**：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立  

## 设计模式三大分类

- **创建型模式**：对象实例化的模式，用于解耦对象的实例化过程

- **结构型模式**：把类或对象结合在一起形成一个更大的结构

- **行为型模式**：类和对象交互，职责划分

### 创建型模式

1. **单例模式**：某个类只能有一个实例，提供一个全局的访问点

2. **工厂方法模式**：定义一个创建对象的接口，让子类决定实例化哪个工厂类

3. **抽象工厂模式**：接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象 

4. **建造者模式**：封装一个复杂对象的构建过程

5. **原型模式**：通过复制现有的实例来创建新的实例


### 结构型模式

1. **适配器模式**：将一个类的接口转换成希望的另一个接口，需要引进一个适配器类，在里面注入适配器类对象实例

2. **桥接模式**：将继承关系转化成关联关系
3. **组合模式**：一个对象中包含其他对象 ，将对象称为节点，即一个根节点包含许多子节点 
4. **装饰模式**：动态给对象添加新的功能，装饰类，实现类重写方法扩展

5. **外观模式**：提供了一个统一的接口（第三者），用来访问子系统中的一群接口 
6. **享元模式**：共享的对象必须是细粒度对象 
7. **代理模式**：为对象提供一个代理，以便控制这个对象的访问


### 行为型模式

1. **访问者模式**：元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作 
2. **模板模式**：父类定义算法结构，子类具体实现

3. **策略模式**：封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法 
4. **状态模式**：允许一个对象在其对象内部状态改变时改变它的行为 
5. **观察者模式**：对象间一对多的依赖关系，当一个对象发生变化，会自动通知他的依赖对象

6. **备忘录模式**：保存一个对象的某个状态，以便在适当的时候恢复对象 
7. **中介者模式**：用一个中介对象来封装一系列的对象交互 
8. **迭代器模式**：借助Iterator 接口，遍历访问聚合对象中各个元素
9. **解释器模式**：实现了一个表达式接口，该接口解释一个特定的上下文 
10. **命令模式**：请求以命令的形式包裹在对象中，并传给调用对象。调用对象去找可以处理该命令的对象，该对象执行命令

11. **责任链模式**：为请求创建一个接收者对象，每个接受者都包含对另一个接收者的引用


