# 设计模式

## 设计模式三大分类

- **创建型模式**：对象实例化的模式，用于解耦对象的实例化过程

- **结构型模式**：把类或对象结合在一起形成一个更大的结构

- **行为型模式**：类和对象交互，职责划分

### 创建型模式

1. **单例模式**：某个类只能有一个实例，提供一个全局的访问点

2. **工厂方法模式**：定义一个创建对象的接口，让子类决定实例化哪个工厂类

3. **抽象工厂模式**：接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象 

4. **建造者模式**：封装一个复杂对象的构建过程

5. **原型模式**：通过复制现有的实例来创建新的实例


### 结构型模式

1. **适配器模式**：将一个类的接口转换成希望的另一个接口，需要引进一个适配器类，在里面注入适配器类对象实例

2. **桥接模式**：将继承关系转化成关联关系
3. **组合模式**：一个对象中包含其他对象 ，将对象称为节点，即一个根节点包含许多子节点 
4. **装饰模式**：动态给对象添加新的功能，装饰类，实现类重写方法扩展

5. **外观模式**：提供了一个统一的接口（第三者），用来访问子系统中的一群接口 
6. **享元模式**：共享的对象必须是细粒度对象 
7. **代理模式**：为对象提供一个代理，以便控制这个对象的访问


### 行为型模式

1. **访问者模式**：元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作 
2. **模板模式**：父类定义算法结构，子类具体实现

3. **策略模式**：封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法 
4. **状态模式**：允许一个对象在其对象内部状态改变时改变它的行为 
5. **观察者模式**：对象间一对多的依赖关系，当一个对象发生变化，会自动通知他的依赖对象

6. **备忘录模式**：保存一个对象的某个状态，以便在适当的时候恢复对象 
7. **中介者模式**：用一个中介对象来封装一系列的对象交互 
8. **迭代器模式**：借助Iterator 接口，遍历访问聚合对象中各个元素
9. **解释器模式**：实现了一个表达式接口，该接口解释一个特定的上下文 
10. **命令模式**：请求以命令的形式包裹在对象中，并传给调用对象。调用对象去找可以处理该命令的对象，该对象执行命令

11. **责任链模式**：为请求创建一个接收者对象，每个接受者都包含对另一个接收者的引用


