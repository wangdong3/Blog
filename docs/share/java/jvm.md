# JVM  

[[toc]]

## JVM内存区域

- **线程共享**

  - 堆（对象实例、对象数组）
    > 基于分代的思想：

    ```tex
    新生代（1/3）
    	Eden（8）
    	survivor1（1）
    	survivor2（1）
    
    老年代（2/3）
    ```

  -  方法区 | 元空间（JDK1.8）（类信息、常量、静态变量、即时编译器编译的代码）

- **线程私有**

  -  程序计数器（指向当前线程正在执行的字节码的指令的地址（行号））

  -  本地方法栈（当前线程运行native方法所需数据、指令、返回地址）

  - 虚拟机栈  

       ```tex
       栈帧（方法）:
       
           1.局部变量表（方法中定义的变量）
           
           2.操作数栈（值入栈）
           
           3.动态链接（动态运行时，符号引用指针）
           
           4.返回地址		
           
       ```
  

![](./image/jvm.png)

## 类加载器  

- 任意一个类，都由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都有一个独立的类名称空间。

- 因此，比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那么这两个类就必定不相等。

- 这里的“相等”，包括代表类的 Class 对象的 equals() 方法、isInstance() 方法的返回结果，也包括使用 instanceof 关键字做对象所属关系判定等情况。

**加载器种类：**

   - 启动类加载器：负责将存放在 `<JAVA_HOME>\lib` 目录中的，并且能被虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。
   - 扩展类加载器：负责加载 `<JAVA_HOME>\lib\ext` 目录中的所有类库，开发者可以直接使用扩展类加载器。
   - 应用程序类加载器：由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，所以一般也称它为“系统类加载器”。它负责加载用户类路径（classpath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

**双亲委派模型：**

- 双亲委派模型是描述类加载器之间的层次关系。它要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。（父子关系一般不会以继承的关系实现，而是以组合关系来复用父加载器的代码）
- 工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（找不到所需的类）时，子加载器才会尝试自己去加载。（在 java.lang.ClassLoader 中的 loadClass() 方法中实现该过程。）
- 原因：像 java.lang.Object 这些存放在 rt.jar 中的类，无论使用哪个类加载器加载，最终都会委派给最顶端的启动类加载器加载，从而使得不同加载器加载的 Object 类都是同一个。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在 classpath 下，那么系统将会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无法保证。

## 类加载过程  

**类加载过程**：加载 -- 》验证 -- 》准备 -- 》解析 -- 》初始化 

1. 加载：

   1. ）通过类的全限定名获取该类的二进制字节流

   2. ）将二进制流所代表的静态结构转化为方法区的运行时数据结构

   3. ）在内存中创建一个代表该类的java.lang.Class对象，作为方法区中这个类的各种数据的访问入口

2. 验证：

   1. ）文件格式，字节流是否符合class文件格式的规范，并且能被当前版本的虚拟机处理
   2. ）元数据验证 ，对字节码描述信息进行语义分析，确保其符合java语法规范
   3. ）字节码验证 对方法体进行语义分析，保证方法在运行时不会对虚拟机造成危害
   4. ）符号引用验证，在解析阶段，确保解析正常执行

3. 准备：正式为类变量（或者静态成员变量）分配内存并设置初始值，这些变量（不包括实例变量）所使用的内存都在方法区进行分配

4. 解析：虚拟机将常量池中的符号引用替换为直接引用

5. 初始化：执行类构造器`<clinit>()`方法的过程

   `<clinit>()`方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。

## 内存分配与回收策略  

- **对象优先在Eden区分配**

- **大对象直接进入老年代**：-XX:PretenureSizeThreshold 参数，大于这个设置值的对象直接在老年代分配，这样做的目的是避免在 Eden 区及两个 Survivor 区之间发生大量的内存复制。

- **长期存活的对象将进入老年代**：JVM 给每个对象定义了一个对象年龄计数器。当新生代发生一次 Minor GC 后，存活下来的对象年龄 +1，当年龄超过一定值时，就将超过该值的所有对象转移到老年代中去。使用 -XXMaxTenuringThreshold 设置新生代的最大年龄，只要超过该参数的新生代对象都会被转移到老年代中去。

- **动态对象年龄判定**：如果当前新生代的 Survivor 中，相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄 >= 该年龄的对象就可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。

- **空间分配担保**：通过清除老年代中废弃对象来扩大老年代空闲空间，以便给新生代作担保。

  **可能触发 JVM 进行 Full GC的情况：**

  - System.gc() 方法的调用
  - 老年代空间不足
  - 永久代空间不足

## 垃圾回收算法

- 判断对象是否存活：

  - 引用计数法：在对象头维护着一个 counter 计数器，对象被引用一次则计数器 +1；若引用失效则计数器 -1。当计数器为 0 时，就认为该对象无效了。弊端：难解决对象之间循环引用的问题。

  - 可达性分析法：所有和 GC Roots 直接或间接关联的对象都是有效对象，和 GC Roots 没有关联的对象就是无效对象。

    GC Roots 是指：

    - Java 虚拟机栈（栈帧中的本地变量表）中引用的对象
    - 本地方法栈中引用的对象
    - 方法区中常量引用的对象
    - 方法区中类静态属性引用的对象

    GC Roots 并不包括堆中对象所引用的对象，这样就不会有循环引用的问题。
- 垃圾回收算法  
  - 复制算法（新生代）
  - 标记-清理
  - 标记-整理
  - 分代收集算法
## JVM调优

```properties
控制台打印gc日志，通过设置JVM参数设置

-Xms20m -Xmx20m -Xmn10m -XX:+PrintGCDetails 
-XX:+PrintGCTimeStamps 打印日志信息
-Xloggc:log_gc.log gc日志输出文件
```