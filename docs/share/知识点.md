## Java基础  
String常量池：字符串常量放在常量池中实现复用，指向常量池中同一个内存地址；

new：创建新的对象，指向全新的内存地址；String类的intern方法创建返回一个常量池中的固定对象

为什么String是不可变的：成员变量final，并且没有set方法来修改

set如何保证不重复

反射的原理和应用场景

concurrentHashMap内部原理，如何保证线程安全

NIO与BIO的区别  

抽象类与接口的区别

## java并发  

sleep与wait区别：sleep释放CPU资源，不释放锁，Object.wait释放锁，需要notify唤醒线程，重新获取锁；

notify与notifyall：notify唤醒一个线程，并允许它去获取锁，notifyall唤醒所有等待这个对象的线程，允许他们去获取对象锁；

	注意：如果要把notify和wait方法放在一起用的话，必须先调用notify后调用wait，因为如果调用完wait，该线程就已经不是currentthread了。

Synchronized与volatile：Synchronized对象锁；volatile修饰变量，保证最新；

Synchronized：
	锁重入：线程得到对象锁后，再次请求此对象锁，可再次得到；在Synchronized方法内部再次调用其他Synchronized方法时；
	同步方法：线程A调用加锁的A方法，或得到对象锁，等A方法执行完，其他线程才能调用A方法
	同步代码块：缩小同步范围，提高执行效率，可指定锁对象
	
	*Synchronized加到static方法给class类上锁，加到非静态方法是给对象上锁
	
volatile：使变量在多个线程间可见；强制从公共堆栈取得变量值，而不是从线程私有数据栈取值

同步锁，互斥锁

thread的join方法：等待子线程终止；join方法的原理就是调用wait方法进行等待操作，子线程执行完JVM会自动调用notify方法唤醒主线程，主线程继续执行；

线程池：
​	线程池参数：核心线程数、最大线程数、线程空闲存活时长、存储任务的阻塞队列、非核心线程超时时长、线程工厂

线程的状态：新建、就绪、运行、阻塞、死亡

ReentrantLock

Lock接口和Synchronized比较

ThreadLocal,ThreadLocalMap：ThreadLocal为每一个线程提供独立的变量副本，隔离了多个线程对数据的访问冲突；

submit和excute

FutureTask

乐观锁和悲观锁

死锁

原子性操作

分布式锁有哪些，怎么实现的

## 事务  

数据库事务隔离级别：
​	读未提交；导致脏读
​	读提交；不可重复读，幻读
​	重复读；多次读是一致的
​	串行化；所有事务串行执行

读写锁

事务管理器

声明式事务实现原理：

如何回滚事务：在上下文正在执行的代码中出现异常，事务代码会捕获异常，做出回滚决定 


## Java内存模型  

堆：存放对象实例及数组，线程共享，在虚拟机启动时创建；垃圾收集的主要区域；
虚拟机栈：局部变量表，基本类型，引用类型；编译期完成分配；
方法区：已被虚拟机加载的类信息，常量，静态变量，即时编译后的代码；常量池的回收，类型的卸载；
程序计数器：当前线程所执行的字节码行号指示器；
本地方法栈：为native方法服务；

## Java定位内存溢出  


## 垃圾收集  

分代、复制算法、标记-整理、标记-清理

## Java类加载机制  

加载-》验证-》准备-》解析-》初始化

## spring  

依赖注入，控制反转

spring注解

AOP

bean自动装配

事务管理

代理

Spring注入的几种方式：set注入；构造函数注入；p命名空间注入

spring源码实现原理，设计模式

springMVC拦截器


## springboot怎么自动装配  


## Mybatis  

如何防止SQL注入

SQL优化  

二级缓存  

## 中间件  

Tomcat实现原理

集群数据库同步问题  
