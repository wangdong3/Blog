1.概念：
集群：集群中的多台服务器做相同的事情
分布式：多个服务器做不同的事情

问题--》方案

---
系统崩溃，服务器宕机，--》如何高可用呢，搞多台服务器，一台服务器出现问题，直接换到另一台继续提供服务

随着业务壮大，系统的响应时间变慢，吞吐量成了瓶颈--》搭建集群，负载均衡，分散系统压力

分布式的产生：
面对复杂的业务，业务拆分，各个服务分散在不同的服务器，但同时对外还是一个整体的服务，简而言之 就是一组在不同服务器上相互协作的系统。

分布式后，还要保证性能、可用、弹性--》一系列的技术栈产生

## 分布式通信

​	RPC和MQ
​		RPC不能流量削峰，MQ可以
​		RPC不能广播，MQ可以
​		RPC模块之间不能解耦

		MQ不能保证延迟时间
		MQ不适合搞强一致性事务
		增加系统复杂度

分布式资源管理和负载调度
	集中式结构
	非集中式结构

	单体调度
	两层调度
	共享状态调度

## 分布式存储

​	主备、sharding分片
​	cap理论
分布式计算
​	MapReduce
​	stream
分布式可靠性
​	负载均衡
​	流量控制
​	故障隔离

## 分布式锁：

> 高并发下同一时间只能有一个线程可执行方法

### 基于数据库：

​	**悲观锁**：`select ... for update` ，使用for update锁定行，如果执行成功立即返回，否则一直阻塞；

​		优点：保证数据强一致性

​		缺点：锁长时间不释放，会一直占用数据库连接，可能会将数据库连接池撑爆，影响其他服务；优先获得锁的线程如果因为某些原因，一直没有释放掉锁，可能会导致死锁；高并发大量请求排队，会影响数据库稳定性，消耗服务CPU。

​	**乐观锁**：表中添加时间戳或版本号字段 `update xx set version = new_version where xx=yy and version = old_version`

​		优点：实现简单，复杂度低，保证数据一致性

​		缺点：性能低，有锁表风险；长时间不提交事务，会占用连接资源；可靠性差； 

### 基于Redis

	set命令：set key value ex time nx
	lua脚本：
	if redis.call('setNx',KEYS[1],ARGV[1]) then if redis.call('get', KEYS[1])==ARGV[1] then return redis.call('expire', KEYS[1], ARGV[2]) else return 0 end end
	if redis.call('get', keys[1]) == argv[1] then return redis.call('del', keys[1]) 
	else return 0 
	end 
​	实现思想：使用setnx命令加锁，并使用expire给锁加一个超时时间，超过该时间，则自动释放锁；锁的value值为随机生成的id，释放锁时要判断下，是不是该锁。

​	优点：可靠性较好高；性能好；cap模型属于AP

​	缺点：复杂度较高；可靠性不如zookeeper；锁删除失败，过期时间不好控制；非阻塞，获取锁失败，需要不断轮询获取锁，消耗CPU资源

使用过程中可能会出现的问题：

```
（1）业务操作异常，未能走到释放锁，锁得不到释放，可能会产生死锁

（2)try catch finally解决上一个问题，除程序抛异常外，程序崩溃，服务器宕机，重启等也可能会导致锁的释放没有执行

（3）解决上一个问题，需要给锁设置超时时间；另外加锁，设置超时时间可能并不是原子操作，在设置超时时间时，程序崩溃，未能成功设置超时时间也可能导致死锁

（4）使用lua脚本，或者set原生命令，增加ex,nx,px等参数，加锁和设置超时时间在一条命令上执行

（5）高并发场景下，可能超时时间不合理，A线程业务未处理完 ，锁自动释放，B线程获得锁，开始执行业务，A线程业务执行完释放锁，会把B线程刚加的锁给删掉了，等到B线程业务处理完，释放锁时可能就会出错

（6）解决上一个问题，就需要加锁时，value值设置为唯一值，释放锁时，通过这个唯一id，判断是不是该锁；超时时间的设置，在加锁成功后，启动一个守护线程，守护线程每隔三分之一超时时间就去延迟锁的超时时间（续命），业务处理完，要关闭守护线程

```

### 基于zookeeper

​	实现思想：zookeeper是一个为分布式应用提供一致性服务的开源组件，其内部是一个分层文件系统目录结构，线程加锁的时候，会在指定目录新建一个临时顺序节点，获取目录下所有子节点，寻找比自己小的兄弟节点，如果没有，那么当前线程的顺序节点最小，则获取锁成功。线程释放锁时会删除自己的节点，其他线程监听到变更事件，判断自己是不是最小节点，获取锁

​	优点：可靠性高，cap模型属于CP

​	缺点：实现复杂度高，性能不如Redis