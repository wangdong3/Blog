1.概念：
集群：集群中的多台服务器做相同的事情
分布式：多个服务器做不同的事情

问题--》方案

---
系统崩溃，服务器宕机，--》如何高可用呢，搞多台服务器，一台服务器出现问题，直接换到另一台继续提供服务

随着业务壮大，系统的响应时间变慢，吞吐量成了瓶颈--》搭建集群，负载均衡，分散系统压力

分布式的产生：
面对复杂的业务，业务拆分，各个服务分散在不同的服务器，但同时对外还是一个整体的服务，简而言之 就是一组在不同服务器上相互协作的系统。

分布式后，还要保证性能、可用、弹性--》一系列的技术栈产生

## 分布式通信

​	RPC和MQ
​		RPC不能流量削峰，MQ可以
​		RPC不能广播，MQ可以
​		RPC模块之间不能解耦

		MQ不能保证延迟时间
		MQ不适合搞强一致性事务
		增加系统复杂度

分布式资源管理和负载调度
	集中式结构
	非集中式结构

	单体调度
	两层调度
	共享状态调度

## 分布式存储

​	主备、sharding分片
​	cap理论
分布式计算
​	MapReduce
​	stream
分布式可靠性
​	负载均衡
​	流量控制
​	故障隔离

## 分布式锁：

> 高并发下同一时间只能有一个线程可执行方法

### 基于数据库：

​	**悲观锁**：`select ... for update` ，使用for update锁定行，如果执行成功立即返回，否则一直阻塞；

​		优点：保证数据强一致性

​		缺点：锁长时间不释放，会一直占用数据库连接，可能会将数据库连接池撑爆，影响其他服务；优先获得锁的线程如果因为某些原因，一直没有释放掉锁，可能会导致死锁；高并发大量请求排队，会影响数据库稳定性，消耗服务CPU。

​	**乐观锁**：表中添加时间戳或版本号字段 `update xx set version = new_version where xx=yy and version = old_version`

​		优点：实现简单，复杂度低，保证数据一致性

​		缺点：性能低，有锁表风险；长时间不提交事务，会占用连接资源；可靠性差； 

### 基于Redis


​	实现思想：使用setnx命令加锁，并使用expire给锁加一个超时时间，超过该时间，则自动释放锁；锁的value值为随机生成的id，释放锁时要判断下，是不是该锁。

​	优点：可靠性较好高；性能好；cap模型属于AP

​	缺点：复杂度较高；可靠性不如zookeeper；锁删除失败，过期时间不好控制；非阻塞，获取锁失败，需要不断轮询获取锁，消耗CPU资源


基于zookeeper

​	实现思想：zookeeper是一个为分布式应用提供一致性服务的开源组件，其内部是一个分层文件系统目录结构，线程加锁的时候，会在指定目录新建一个临时顺序节点，获取目录下所有子节点，寻找比自己小的兄弟节点，如果没有，那么当前线程的顺序节点最小，则获取锁成功。线程释放锁时会删除自己的节点，其他线程监听到变更事件，判断自己是不是最小节点，获取锁

​	优点：可靠性高，cap模型属于CP

​	缺点：实现复杂度高，性能不如Redis