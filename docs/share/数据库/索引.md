## 数据库-索引

### 索引分类  


- B-tree索引  
	CREATE INDEX命令创建B-tree索引
	
	```sql
	CREATE INDEX test1_id_index ON test1 (id);
	```
	使用场景：B-tree可以处理对可以排序成某些顺序的数据的等式和范围查询
	
	```sql
	<
	<=
	=
	>=
	>
	BETWEEN
	IN
	IS NULL
	IS NOT NULL
	LIKE
	```
	
	```sql
	--示例
	create table test_tb1(c1 int,c2 int);
	insert into test_tb1 select round(random()*100),round(random()*1000) from generate_series(1,200000);
	select pg_size_pretty(pg_table_size('test_tb1'));
	7104 kB
	
	--全表扫描
	select * from test_tb1;
	0.209s
	select count(*) from test_tb1;
	0.079s
	
	--c1单索引扫描
	create index test_tb1_idx1 on test_tb1(c1);
	时间: 0.423s
	select pg_size_pretty(pg_relation_size('test_tb1_idx1'));
	4408 kB
	
	drop index test_tb1_idx1;
	
	create index test_tb1_idx2 on test_tb1(c2);
	select pg_size_pretty(pg_relation_size('test_tb1_idx2'));
	4408 kB
	
	create index test_tb1_idx3 on test_tb1(c1,c2);
	select pg_size_pretty(pg_relation_size('test_tb1_idx3'));
	4408 kB
	
	explain (analyze,buffers) select count(*) from test_tb1 where c1=99 and c2=999;
	
	--插件
	select * from pg_extension;
	create extension pageinspect;
	
	select * from heap_page_items(get_raw_page('test_tb1',0)) order by lp_off desc;
	
	SELECT * from page_header(get_raw_page('test_tb1', 0));
	
	create index test_tb1_idx1 on test_tb1(c1);
	
	
	select * from bt_metap('test_tb1_idx1');   
	
	select * from bt_page_stats('test_tb1_idx1',209); 
	
	select * from bt_page_items('test_tb1_idx1',3); 
	
	TRUNCATE table test_tb1;
	drop table test_tb1;
	```
	
	**实现原理：**
	
	btree索引基于B+树实现
	
	B+树数据结构：
	
	使用B+树实现的优点：压缩了树的层级，减少磁盘IO。
	
	
	
- hash索引  
	Hash索引只能处理简单的等式比较。当使用=运算符进行比较时，查询计划器将考虑使用Hash索引
	
	```sql
	CREATE INDEX name ON table USING HASH (column);
	```
```
	
- gin倒排索引  
	当需要搜索多值类型内的VALUE时，适合多值类型，例如数组、全文检索、TOKEN
	
	``` sql
	<@  包含于
	@>  数组的操作符，表示“包含”的意思
	=   相等
	&&  重叠（是否有相同元素）
```

### 每种索引的应用场景及优缺点

### 数据库选择索引原理  

- 代价评估算法  

### 索引被使用率查看  

### 索引的物理和逻辑组织形式  

### 索引和并发问题
```

```