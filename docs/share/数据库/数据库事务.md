# MySQL事务

## 事务四大特性

ACID：原子性、一致性、隔离性、持久性

**原子性** 

通过`undo log`实现，记录了操作的反向逻辑

操作数据之前，将数据备份到`undo log`，然后进行数据的修改。如果出现了错误或者触发了回滚，系统可以通过`undo log`回到数据操作前的状态

**一致性** 

 通过原子性、持久性和隔离性来实现

**隔离性** 

读写锁 + `MVCC`实现

**持久性** 

通过`redo logo`实现，`redo log`记录数据的备份



## 事务隔离级别

`SQL`标准考虑了三个必须在并行事务之间避免的现象

（1）脏堵：一个事务读取了另一个事务还未提交的数据

（2）不可重复读：一个事务读取前面读取过的数据，发现该数据已经被另一个已提交的事务修改过

（3）幻读：一个事务重新执行一次查询，发现返回的数据因为最近其他已经提交的事务发生了改变

为了避免这几个现象，`SQL`标准定义了四个事务隔离级别

- 读未提交
- 读已提交
- 可重复读
- 串行化

不同隔离级别可能会导致不同的并发异常

| 事务隔离级别 | 脏读 | 不可重复读 | 幻读 |
| ------------ | ---- | ---------- | ---- |
| 读未提交     | 是   | 是         | 是   |
| 读已提交     |      | 是         | 是   |
| 可重复读     |      |            | 是   |
| 串行化       |      |            |      |



## 锁

`MySQL`中两类锁：共享锁和排它锁

​	共享锁：数据只读，对读取锁定

​	排它锁：当前事务执行`insert | delete | update`，其他事务不能读取数据，对写入锁定

### 锁的粒度

​	记录

​	表

​	数据库

### 基于锁的并发控制流程

（1）事务根据自己对数据的操作类型，向锁管理器申请相应的锁

（2）锁管理器根据当前数据是否已经有锁，以及申请的锁和持有的锁是否有冲突决定是否为该请求授予锁

（3）若锁被授予，那么事务继续执行；若被拒绝，则继续等待，直到锁被其他事务释放