# MySQL事务

在 `MySQL`中，`InnoDB`引擎是支持事务的。

## 事务四大特性

ACID（`Atomicity`、`Consistency`、`Isolation`、`Durability`），即原子性、一致性、隔离性、持久性

**原子性** 

通过`undo log`实现，记录了操作的反向逻辑

操作数据之前，将数据备份到`undo log`，然后进行数据的修改。如果出现了错误或者触发了回滚，系统可以通过`undo log`回到数据操作前的状态

**一致性** 

 通过原子性、持久性和隔离性来实现

**隔离性** 

读写锁 + `MVCC`实现

**持久性** 

通过`redo logo`实现，`redo log`记录数据的备份



## 事务隔离级别

`SQL`标准考虑了三个必须在并行事务之间避免的现象

（1）脏堵：一个事务读取了另一个事务还未提交的数据

（2）不可重复读：一个事务读取前面读取过的数据，发现该数据已经被另一个已提交的事务修改过

（3）幻读：一个事务重新执行一次查询，发现返回的数据因为最近其他已经提交的事务发生了改变

为了避免这几个现象，`SQL`标准定义了四个事务隔离级别

- 读未提交
- 读已提交
- 可重复读
- 串行化

不同隔离级别可能会导致不同的并发异常

| 事务隔离级别 | 脏读 | 不可重复读 | 幻读 |
| ------------ | ---- | ---------- | ---- |
| 读未提交     | 可能 | 可能       | 可能 |
| 读已提交     |      | 可能       | 可能 |
| 可重复读     |      |            | 可能 |
| 串行化       |      |            |      |

`MySQL` 事务默认隔离级别是可重复读，并且可重复读解决了幻读问题（使用的间隙锁）。



### 如何实现隔离级别

可重复读、读已提交：

 	采用 `MVCC` (多版本并发控制) 

串行化：

​	**共享锁**：读锁，数据只读；必须等其他共享锁都释放完之后才能进行修改操作；

​	例：`select * from user lock in share mode;`

​	**排它锁**：写锁

​	例：`select * from user where id = 1 for update;`



#### 基于版本并发控制

**快照**（一致性视图）

可重复读：在事务开始的时候生成一个当前事务的全局性的快照；

读已提交：每次执行语句的时候都会重新生成一次快照；



快照读取版本数据，遵循的规则：

1. 当前事务内的更新可以读到；

2. 版本为提交的，不能读到；

3. 版本已提交，但是是在快照生成后提交的，不能读到；

4. 版本已提交，但是是在快照生成前提交的，可以读到；



#### 基于锁的并发控制

（1）事务根据自己对数据的操作类型，向锁管理器申请相应的锁

（2）锁管理器根据当前数据是否已经有锁，以及申请的锁和持有的锁是否有冲突决定是否为该请求授予锁

（3）若锁被授予，那么事务继续执行；若被拒绝，则继续等待，直到锁被其他事务释放



## 总结

MySQL如何实现隔离级别；MVCC实现的基本原理，以及锁的并发控制。