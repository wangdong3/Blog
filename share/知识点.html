<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>知识点 | 文档管理</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="文档管理">
    
    <link rel="preload" href="/blog/assets/css/0.styles.d7574f63.css" as="style"><link rel="preload" href="/blog/assets/js/app.c61f9dc1.js" as="script"><link rel="preload" href="/blog/assets/js/2.388d52cb.js" as="script"><link rel="preload" href="/blog/assets/js/34.dd52f826.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.e48886a1.js"><link rel="prefetch" href="/blog/assets/js/11.0db0625b.js"><link rel="prefetch" href="/blog/assets/js/12.f1057769.js"><link rel="prefetch" href="/blog/assets/js/13.b442abea.js"><link rel="prefetch" href="/blog/assets/js/14.daba5dbf.js"><link rel="prefetch" href="/blog/assets/js/15.c8b8c48c.js"><link rel="prefetch" href="/blog/assets/js/16.7215a435.js"><link rel="prefetch" href="/blog/assets/js/17.2fc8aa9b.js"><link rel="prefetch" href="/blog/assets/js/18.616d526d.js"><link rel="prefetch" href="/blog/assets/js/19.1c4d1a0e.js"><link rel="prefetch" href="/blog/assets/js/20.29879dee.js"><link rel="prefetch" href="/blog/assets/js/21.1d2b8804.js"><link rel="prefetch" href="/blog/assets/js/22.d0629f3d.js"><link rel="prefetch" href="/blog/assets/js/23.93a8ebaf.js"><link rel="prefetch" href="/blog/assets/js/24.324df21c.js"><link rel="prefetch" href="/blog/assets/js/25.b6c9075c.js"><link rel="prefetch" href="/blog/assets/js/26.99b267df.js"><link rel="prefetch" href="/blog/assets/js/27.95b0c3cd.js"><link rel="prefetch" href="/blog/assets/js/28.d14ae9b5.js"><link rel="prefetch" href="/blog/assets/js/29.43834437.js"><link rel="prefetch" href="/blog/assets/js/3.7cefba26.js"><link rel="prefetch" href="/blog/assets/js/30.bb384616.js"><link rel="prefetch" href="/blog/assets/js/31.20f86835.js"><link rel="prefetch" href="/blog/assets/js/32.c742083f.js"><link rel="prefetch" href="/blog/assets/js/33.b2366c8c.js"><link rel="prefetch" href="/blog/assets/js/35.17416a72.js"><link rel="prefetch" href="/blog/assets/js/36.ff166262.js"><link rel="prefetch" href="/blog/assets/js/4.2f1c3a5f.js"><link rel="prefetch" href="/blog/assets/js/5.4c55088b.js"><link rel="prefetch" href="/blog/assets/js/6.c9d0387c.js"><link rel="prefetch" href="/blog/assets/js/7.08c24d6d.js"><link rel="prefetch" href="/blog/assets/js/8.f72ad2ba.js"><link rel="prefetch" href="/blog/assets/js/9.c27fcf06.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.d7574f63.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/img/logo.png" alt="文档管理" class="logo"> <span class="site-name can-hide">文档管理</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/share/" class="nav-link router-link-active">
  Share
</a></div><div class="nav-item"><a href="http://blog.csdn.net" target="_blank" rel="noopener noreferrer" class="nav-link external">
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/wangdong3" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/share/" class="nav-link router-link-active">
  Share
</a></div><div class="nav-item"><a href="http://blog.csdn.net" target="_blank" rel="noopener noreferrer" class="nav-link external">
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/wangdong3" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据结构</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据库</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>中间件</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>知识点</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/share/知识点.html" class="active sidebar-link">知识点</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>分布式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Spring</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>其他</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="知识点">知识点</h1> <h2 id="一、计算机基础">一、计算机基础</h2> <p><strong>机器数: 原码 补码 反码</strong></p> <blockquote><p>练习： [x]补=1 1110100， [y]补=10110000。若整型变量 z=2*x+y/2，则 z 的机器数为（ ）。</p></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>第一步：根据补码算反码（正数的补码与其原码相同；负数的补码是在其反码的末位加1）

反码: x: 11110011   y: 10101111

第二步：根据反码算原码（正数的反码与其原码相同；负数的反码是对其原码逐位取反，符号位除外）

原码: x: 10001100   y: 11010000

第三步：分别计算2*x和y/2

10001100 向左移一位
2*x =  10011000

11010000  向右移一位
y/2 = 10101000

第四步：计算2*x+y/2

10011000
+  10101000

z=2*x+y/2 = 11000000


</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h2 id="二、java基础">二、Java基础</h2> <p><strong>1.String 与 Integer :</strong></p> <div class="language- extra-class"><pre><code>【String】
1.String常量池：字符串常量放在常量池中实现复用，指向常量池中同一个内存地址；

2.为什么String是不可变的：成员变量final，并且没有set方法来修改
</code></pre></div><p>​<br>
​    【Integer】
​    java中一个字节以内的Integer，-128~127都是存在一个常量池中的，所以他们的引用也是相同的
​<br>
​    	Integer i1 = 127;
​    	Integer i2 = 127;
​<br>
​    	System.out.println(i1 == i2);
​<br>
​    	结果是true；
​    	
​        ---------------------------------
​<br>
自动装箱的时候会调用Integer.valueof方法，会与IntegerCache里面的最大最小值做比较，在这个范围里的值就会直接取IntegerCache里的
Integer i1 = 128;
Integer i2 = 128;</p> <div class="language- extra-class"><pre><code>	System.out.println(i1 == i2);

	结果是false；
	
	---------------------------------
	Integer i1 = 2000000000;
	Integer i2 = 2000000000;

	System.out.println(i1 == i2);
	
	结果是false；
</code></pre></div><p><strong>2.new</strong>：</p> <div class="language- extra-class"><pre><code>创建新的对象，指向全新的内存地址；

String类的intern方法创建返回一个常量池中的固定对象
</code></pre></div><p><strong>3.static</strong></p> <div class="language- extra-class"><pre><code>1、创建独立于对象的域变量或者方法

2、修饰成员、成员方法、代码块、静态内部类

3、类加载时就会加载被static修饰的部分，JVM会为静态变量分配内存空间

4、静态方法可以访问静态的变量，不能访问非静态的；非静态的可以访问静态的
</code></pre></div><p><strong>4.final</strong></p> <div class="language- extra-class"><pre><code>1.修饰类，这个类不能被继承

2、修饰方法，这个方法不能被重写
	一个类的private方法会隐式的指定为final方法
	如果父类有final方法，子类不能去重写
	
3.修饰成员变量，必须要赋初始值，而且只能初始化一次
	被final修饰的成员变量赋值两种方式：（1）直接赋值（2）在构造方法中赋初始值
	如果修饰的成员变量是基本类型，那么这个变量的值不能改变
	如果修饰的是引用类型，那么表示引用地址不能改变，引用指向的对象的内容还是可以改变的
</code></pre></div><p><strong>5.transient</strong></p> <div class="language- extra-class"><pre><code>关于对象序列化，类实现serializable接口
	对象转成字节序列，序列化后的对象可以写入到数据库或文件中，网络传输
	反序列化，序列化后的字节序列恢复原先的Java对象
	
transient：让对象中的某些成员变量属性不被序列化
	不需要被保存，节省存储空间
</code></pre></div><p><strong>6.反射</strong></p> <div class="language- extra-class"><pre><code>定义：
	在运行状态中，对于任意的一个类，能够知道这个了类的所有属性和方法；对于任何一个对象，都能调用它的任意方法和属性；这种动态获取类信息及动态调用对象的方法功能称之为Java的反射机制。

原理：
	Class.forName(&quot;c.a.xxx&quot;);//java.lang.Class的静态方法，获取类信息
	{
		//通过反射，获取调用进来的类信息，从而获取当前的classLoader
		Class&lt;?&gt; caller = Reflection.getCallerClass();
		//调用native方法，获取class信息
		forName0(className, true, ClassLoader.getClassLoader(caller), caller)
		
	}
</code></pre></div><p><strong>7.抽象类与接口</strong></p> <div class="language- extra-class"><pre><code>定义本身：
	接口是完全抽象的；抽象类是半抽象的；（体现在接口中的方法只有名，没有具体实现；java8有了default方法；抽象类可以有具体方法）
	
	抽象类的成员变量可以是各种类型，而接口中的成员变量只能是public static final
	
使用：
	一个类只能继承一个抽象类，但可以实现多个接口
	抽象类像一个模板，接入像一个行为规范
</code></pre></div><h2 id="三、java集合">三、java集合</h2> <blockquote><p>ArrayList、 LinkedList</p></blockquote> <blockquote><p>HashMap、TreeMap</p></blockquote> <table><thead><tr><th>HashMap</th> <th>TreeMap</th></tr></thead> <tbody><tr><td>1.基于数组 + 链表 - &gt; 红黑树</td> <td>1.基于红黑树，有序</td></tr> <tr><td>2.查询较快，最差O(log n)</td> <td>2.时间复杂度O(log n)</td></tr> <tr><td>3.插入：hashcode(key)、key.equal()确定位置</td> <td>3.增加节点，从根节点出发作为当前节点比较，循环</td></tr> <tr><td>4.删除节点，比较复杂</td> <td>4.删除节点:找到被删除的节点D的子节点C，用C来替代D，不是直接删除D，因为D被C替代了，直接删除C即可<br>子节点C的规则是：右分支最左边，或者 左分支最右边的</td></tr></tbody></table> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token function">put</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span>
<span class="token operator">-&gt;</span>
<span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> k<span class="token punctuation">,</span> v<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

<span class="token comment">//1、判断初始容量，Node&lt;K,V&gt;[] tab若为null，则进行初始化，初始化容量为16。</span>

<span class="token comment">//2、判断tab数组索引位置的值是否为null，是则构造新节点并赋值：tab[i] = newNode(hash, key, value, null);</span>

<span class="token comment">//3、（1）判断tab数组索引位置key值以及hash值与将要插入的元素的key值和hash值是否相等，若相等，覆盖原有的值</span>
    （<span class="token number">2</span>）如果索引所在的位置是<span class="token class-name">TreeNode</span>，将元素插入到<span class="token class-name">TreeNode</span>中：<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    （<span class="token number">3</span>）如果索引所在的位置是链表，将元素插入到链表尾部，当链表元素数量到达<span class="token number">8</span>时，转<span class="token class-name">TreeNode</span>
   						  

<span class="token comment">//4、插入完成后，判断当前容量是否超出初始的负载容量，来确定是否需要扩容</span>

<span class="token punctuation">}</span>

<span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
<span class="token operator">-&gt;</span>
<span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token comment">//1、判断是否容量大于0 ，否则返回 null</span>
<span class="token comment">//2、（1）判断当前索引的hash值以及key值是否等于要找的元素</span>
<span class="token comment">//	 （2）如果当前索引是红黑树，则去树中去遍历查找，直至找到</span>
<span class="token comment">//   （3）如果当前索引是链表，则向后查找，根据hash值和key值去匹配，直至找到</span>

<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><blockquote><p>ConcurrentHashMap</p></blockquote> <div class="language- extra-class"><pre><code>concurrentHashMap内部原理，如何保证线程安全	
</code></pre></div><p>​	锁分段技术
​	读是否加锁，why
​	迭代器是强一致性还是弱一致性的迭代器</p> <blockquote><p>HashSet</p></blockquote> <div class="language- extra-class"><pre><code>set如何保证不重复
</code></pre></div><h2 id="四、io">四、IO</h2> <ul><li>HTTP/tcp/udp网络协议原理</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>HTTP协议是构建在tcp/ip协议之上的，是tcp/ip协议的一个子集；

tcp/ip协议族四层协议：
    应用层：HTTP、FTP、DNS等
    传输层：TCP、UDP
    网络层：处理网络上流动的数据包
    数据链路层：处理连接网络的硬件部分
   
TCP三次握手：
	1）客户端发送SYN标志的连接请求报文段，然后进入SYN_SEND状态，等待服务端的确认
	2）服务端接收到客户端的SYN报文段后，需要发送ACK信息对这个SYN报文段进行确认；同时，是要发送自己的SYN请求信息，服务端会将上述信息放到一个报文段（SYN+ACK报文段）中，一并发送给客户端，此时，服务端进入SYN_RECV状态
	3）客户端收到服务端的SYN+ACK报文段后，会向服务端发送ACK确认报文段，这个报文段发送完毕，客户端和服务端都进入ESTABLISHED状态，完成TCP三次握手
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><ul><li><p>BIO</p> <p>同步阻塞IO</p></li> <li><p>NIO</p></li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>同步非阻塞IO
	
核心类：
	1.Channel(通道) 
		特性：
			双向性
			非阻塞性
			操作唯一性 （通过buffer操作）
		实现：
	2.Buffer
		作用：读写Channel中的数据
		本质：一块内存区域
		属性：
			Capacity（容量）
			Position（位置）
			limit（上限）
			Mark（标记）
	3.Selector
		
步骤：
	1）创建Selector
	2）通过ServerSocketChannel创建Channel通道
	3）为channel通道绑定监听端口
	4）设置channel为非阻塞模式
	5）将channel注册到selector上，监听连接事件
	6）循环等待新的连接
	7）根据就绪状态，调用对应的方法处理业务逻辑
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><ul><li><p>netty</p> <p>netty封装了JDK的NIO，是一个异步事件驱动的网络应用框架，用于快速开发可维护的高性能服务器和客户端</p></li></ul> <h2 id="五、java并发">五、java并发</h2> <h3 id="thread">Thread</h3> <p>sleep()与wait()</p> <div class="language- extra-class"><pre><code>Thread.sleep() 释放CPU资源，不释放锁

Object.wait() 释放锁，需要notify唤醒线程，重新获取锁；
</code></pre></div><p>yield()</p> <blockquote><p>当前线程让出CPU时间片</p></blockquote> <p>notify()与notifyall()</p> <div class="language- extra-class"><pre><code>notify唤醒一个线程，并允许它去获取锁

notifyall唤醒所有等待这个对象的线程，允许他们去获取对象锁；
</code></pre></div><p>join()</p> <blockquote><p>等待子线程终止；</p> <p>join方法的原理就是调用wait方法进行等待操作，子线程执行完JVM会自动调用notify方法唤醒主线程，主线程继续执行；</p></blockquote> <h3 id="threadlocal">ThreadLocal</h3> <blockquote><p>ThreadLocal为每一个线程提供独立的变量副本，隔离了多个线程对数据的访问冲突；</p></blockquote> <h3 id="同步辅助类">同步辅助类</h3> <h4 id="_1-countdownlatch">1.CountDownLatch</h4> <blockquote><p>同步计数器，实现一个或多个线程等待，直到其他线程的操作完成</p></blockquote> <p>使用场景：父线程需要等待子线程的执行结果，才能执行后续操作</p> <p>CountDownLatch countDownLatch = new CountDownLatch(threadCount);</p> <p>子线程执行完成，countDown()，父线程await()等待。</p> <h4 id="_2-cyclicbarrier">2.CyclicBarrier</h4> <blockquote><p>一组线程相互等待，直到达到一个公共的屏障点，各个线程唤醒继续执行后续操作</p></blockquote> <p>private static CyclicBarrier cyclicBarrier = new CyclicBarrier(5);</p> <p>await()</p> <h4 id="_3-semaphore">3.SemaPhore</h4> <blockquote><p>控制同一时间并发线程的数量</p></blockquote> <p>使用场景：对于连接资源有限的情况下，控制并发限制</p> <p>final Semaphore semaphore = new Semaphore(3);</p> <p>acquire()</p> <p>release()</p> <h3 id="锁">锁</h3> <h4 id="synchronized关键字">Synchronized关键字</h4> <div class="language- extra-class"><pre><code> Synchronized：

	同步方法：线程A调用加锁的A方法，或得到对象锁，等A方法执行完，其他线程才能调用A方法
	同步代码块：缩小同步范围，提高执行效率，可指定锁对象	
	加到static方法给class类上锁，加到非静态方法是给对象上锁
	锁重入：线程得到对象锁后，再次请求此对象锁，可再次得到；在Synchronized方法内部再次调用其他
	非公平
</code></pre></div><h4 id="reentrantlock">ReenTrantLock</h4> <h4 id="reentrantreadwritelock">ReenTrantReadWriteLock</h4> <h4 id="stampedlock">StampedLock</h4> <h4 id="condition">Condition</h4></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">10/27/2022, 2:54:03 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/share/中间件/RocketMQ.html" class="prev">
        RocketMQ
      </a></span> <span class="next"><a href="/blog/share/分布式.html">
        /share/分布式.html
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.c61f9dc1.js" defer></script><script src="/blog/assets/js/2.388d52cb.js" defer></script><script src="/blog/assets/js/34.dd52f826.js" defer></script>
  </body>
</html>
